#!/usr/bin/env python3

# general packages
import argparse
import time
import numpy as np
import csv
import os
import math
import re
from rosgraph_msgs.msg import Clock
from rospy.core import traceback
import rostopic
import rospkg
from datetime import datetime
import yaml

# ros packages
import rospy
from std_msgs.msg import Int16
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
import pedsim_msgs.msg as pedsim_msgs
import arena_evaluation_msgs.srv as arena_evaluation_srvs
from arena_evaluation.utils import Pedestrian

# for transformations
from tf.transformations import euler_from_quaternion

# 收集数据
# 这个类的主要作用是收集ROS机器人系统中不同主题(topic)的数据。
# 它通过ROS订阅对象获取传感器、里程计(Odometry)、动作(Twist)和PedsimAgentsDataframe等主题的数据,
# 并将其转换为可读取的格式,如列表、字典等
class DataCollector:
    def __init__(self, topic):
        topic_callbacks = [ # list 列表
            ("scan", self.laserscan_callback),
            ("odom", self.odometry_callback),
            ("cmd_vel", self.action_callback),
            ("pedsim_agents_data", self.pedsim_callback)
        ]

        # 我们尝试从这个列表中找到与当前主题名称匹配的回调函数，并将它赋值给变量 callback。
        try:
            # 创建一个 lambda 匿名函数来执行特定主题名称对应的回调函数。
            callback = lambda msg: [t[1] for t in topic_callbacks if t[0] == topic[1]][0](msg)
        except:
            traceback.print_exc()
            return

        self.full_topic_name = topic[1]
        self.data = None

        print(topic[0])

        # 创建ROS订阅对象
        self.subscriber = rospy.Subscriber(topic[0], topic[2], callback)

    def episode_callback(self, msg_scenario_reset):
        print(msg_scenario_reset)
        
        self.data = msg_scenario_reset.data

    def laserscan_callback(self, msg_laserscan: LaserScan):  # 类型注释 表示输入参数 msg_laserscan 应该是一个类型为 LaserScan 的 ROS 消息对象。
        """
        三目运算符 ... if ... else ... 的详细用法:
            # 使用 if-else 语句
            if x > y:
                z = x
            else:
                z =e
            # 使用三目运算符
            z = x if x > y else y
    列表推导式:[... for val in msg_laserscan.ranges],这是一种快速生成列表的方法。

    round()函数用于将一个数字保留指定位数的小数,math.isnan()函数用于判断一个值是否为 NaN。
    在这段代码中，先使用 math.isnan() 函数判断当前值是否为NaN,如果是,
    则返回msg_laserscan.range_max的值;否则,对当前值进行保留3位小数后返回。

    所以该语句的作用是:使用三目运算符对当前值是否为NaN进行判断,如果是,
    则返回 msg_laserscan.range_max 的值;否则,返回保留3位小数后的val值
    
    注:NaN 是英文 "Not a Number" 的缩写，表示不是一个数字
    NaN 值通常出现在以下情况中：
    计算结果未定义或不确定。
    进行非法操作，如对负数求平方根、除以零等。
    数据类型错误或类型不匹配。
        """
        self.data = [msg_laserscan.range_max if math.isnan(val) else round(val, 3) for val in msg_laserscan.ranges]

    # 使用列表推导式遍历 Laserscan 消息中的每个 range 值。
    # 如果 range 值为 NaN，将其替换为 range_max 的值。
    # 如果 range 值为数字，保留3位小数并添加到数据列表中。
    # 最后将数据列表赋值给订阅者节点对象中的 data 变量。


    def odometry_callback(self, msg_odometry: Odometry):
        pose3d = msg_odometry.pose.pose
        twist = msg_odometry.twist.twist

        self.data = {
            "position": [
                round(val, 3) for val in [
                    pose3d.position.x,
                    pose3d.position.y,
                    euler_from_quaternion(
                        [
                            pose3d.orientation.x, 
                            pose3d.orientation.y,
                            pose3d.orientation.z,
                            pose3d.orientation.w
                        ]
                    )[2] # 在将四元数转换为欧拉角时，使用了[2]来获取机器人绕z轴的旋转角度。
                ]
            ],
            "velocity": [
                round(val, 3) for val in [  # round用于对浮点数进行四舍五入
                    twist.linear.x,
                    twist.linear.y,
                    twist.angular.z
                ]
            ]
            # 最终，这段代码会生成一个如下所示的字典：
            # {
            #     "position": [x, y, theta],
            #     "velocity": [vx, vy, wz]
            # }


        }

    def action_callback(self, msg_action: Twist): # variables will be written to csv whenever an action is published
        self.data = [
            round(val, 3) for val in [
                msg_action.linear.x,
                msg_action.linear.y,
                msg_action.angular.z
            ]
        ]

    def pedsim_callback(self, msg_pedsim: pedsim_msgs.PedsimAgentsDataframe):
        self.data = [
            Pedestrian(
                id = agent.id,
                type = agent.type,
                social_state = agent.social_state,
                position = [agent.pose.position.x, agent.pose.position.y],
                theta = np.arctan2(agent.forces.force.y, agent.forces.force.x),
                destination = [agent.destination.x, agent.destination.y]
            )._asdict()
            for agent
            in msg_pedsim.agent_states
        ]

    # msg_pedsim.agent_states 中的每个元素 agent，生成一个字典，并将所有字典组成一个列表。
    # 最后将这个列表保存在变量self.data 中，以便其他部分的程序进行进一步处理和使用。

    def get_data(self):
        return (
            self.full_topic_name,
            self.data 
        )
    # 使用圆括号()将两个变量封装成一个元组，并以此作为整个函数的返回值。因此,如果调用该函数，
    # 将会返回一个包含两个元素的元组，分别对应 self.full_topic_name 和 self.data 的值。

# 记录数据到指定文件
# 这个类的主要作用是记录ROS机器人系统中不同主题(topic)的数据，并将其保存到CSV文件中。
# 在初始化时，它会订阅给定的主题，并使用DataCollector类从主题获取数据。
# 它还读取配置文件和ROS参数，以确定如何在何时记录数据。
# 该类还负责创建结果目录、写入参数、时间戳和数据等信息，并支持在运行节点时动态更改参数。
# 最后，Recorder类提供了一个数据写入方法，该方法可以将数据写入指定的CSV文件中。
class Recorder:
    def __init__(self, result_dir):
        self.model = rospy.get_param(os.path.join(rospy.get_namespace(), "model"), "")

        self.base_dir = rospkg.RosPack().get_path("arena_evaluation")
        self.result_dir = os.path.join(self.base_dir, "data", result_dir)

        os.makedirs(self.result_dir, exist_ok=True)
        
        self.write_params()

        topics_to_monitor = self.get_topics_to_monitor()
        """
        topics_to_monitor
        [
        ('/burger/scan', <class 'sensor_msgs.msg._LaserScan.LaserScan'>),
        ('/burger/scenario_reset', <class 'std_msgs.msg._Int16.Int16'>), 
        ('/burger/odom', <class 'nav_msgs.msg._Odometry.Odometry'>), 
        ('/burger/cmd_vel', <class 'geometry_msgs.msg._Twist.Twist'>), ('/pedsim_simulator/pedsim_agents_data', <class 'pedsim_msgs.msg._PedsimAgentsDataframe.PedsimAgentsDataframe'>)
        ] 
        """

        topics = rostopic.get_topic_list()
        published_topics = topics[0]

        topic_matcher = re.compile(f"({'|'.join([t[0] for t in topics_to_monitor])})$")

        topics_to_sub = []

        for t in published_topics:
            topic_name = t[0]

            match = re.search(topic_matcher, topic_name)

            if not match: 
                continue

            topics_to_sub.append([topic_name, *self.get_class_for_topic_name(topic_name)])

            # topics_to_sub.append([topic_name, *[t for t in topics_to_monitor if t[0] == match.group()][0]])

        """
        topics_to_sub
        ('topics_to_sub: ', [
        ['/pedsim_simulator/pedsim_agents_data', 'pedsim_agents_data', <class 'pedsim_msgs.msg._PedsimAgentsDataframe.PedsimAgentsDataframe'>], 
        ['/burger/odom', 'odom', <class 'nav_msgs.msg._Odometry.Odometry'>], 
        ['/burger/scan', 'scan', <class 'sensor_msgs.msg._LaserScan.LaserScan'>]
        ])
        """
        # cmd_vel in the beginning of published_topics, so manually add it
        topics_to_sub.append(["/burger/cmd_vel", *self.get_class_for_topic_name("/burger/cmd_vel")])

        self.data_collectors = []

        for topic in topics_to_sub:
            self.data_collectors.append(DataCollector(topic))
            self.write_data(
                topic[1], [
                    "time", "data"
                ],
                mode="w"
            )

        self.write_data("episode", ["time", "episode"], mode="w")
        self.write_data("start_goal", ["episode", "start", "goal"], mode="w")

        self.current_episode = 0

        self.config = self.read_config()

        self.current_time = None
        self.clock_sub = rospy.Subscriber("/clock", Clock, self.clock_callback)
        
        self.scenario_reset_sub = rospy.Subscriber("/scenario_reset", Int16, self.scenario_reset_callback)

        # print(rosparam.print_params("", "/"))

    def scenario_reset_callback(self, data: Int16):
        self.current_episode = data.data

    def clock_callback(self, clock: Clock):
        current_simulation_action_time = clock.clock.secs * 10e9 + clock.clock.nsecs

        if not self.current_time:
            self.current_time = current_simulation_action_time

        time_diff = (current_simulation_action_time - self.current_time) / 1e6 ## in ms

        if time_diff < self.config["record_frequency"]:
            return

        self.current_time = current_simulation_action_time

        for collector in self.data_collectors:
            topic_name, data = collector.get_data()
            
            self.write_data(topic_name, [self.current_time, data])
        
        self.write_data("episode", [self.current_time, self.current_episode])
        self.write_data("start_goal", [
            self.current_episode, 
            rospy.get_param(rospy.get_namespace() + "start", [0, 0, 0]), 
            rospy.get_param(rospy.get_namespace() + "goal", [0, 0, 0])
        ])

    def read_config(self):
        with open(self.base_dir + "/data_recorder_config.yaml") as file:
            return yaml.safe_load(file)  # 在读取未知来源的 YAML 数据时，建议使用 safe_load() 函数而不是 load() 函数，从而增强数据处理的安全性
        # 将yaml文件解析为Python字典格式，最后返回该字典。

    def get_class_for_topic_name(self, topic_name):
        if "/scan" in topic_name:
            return ["scan", LaserScan]
        if "/odom" in topic_name:
            return ["odom", Odometry]
        if "/cmd_vel" in topic_name:
            return ["cmd_vel", Twist]
        if "/pedsim_agents_data" in topic_name:
            return ["pedsim_agents_data", pedsim_msgs.PedsimAgentsDataframe]
        raise ValueError(f"Unknown topic name: {topic_name}")

    # 在ROS节点中,可以通过订阅这些主题,并使用相应的处理函数获取消息内容并进行记录和分析。
    def get_topics_to_monitor(self):
        return [
            (os.path.join(rospy.get_namespace(), "scan"), LaserScan),
            (os.path.join(rospy.get_namespace(), "scenario_reset"), Int16),
            (os.path.join(rospy.get_namespace(), "odom"), Odometry),
            (os.path.join(rospy.get_namespace(), "cmd_vel"), Twist),
            ("/pedsim_simulator/pedsim_agents_data", pedsim_msgs.PedsimAgentsDataframe)
        ]

    # 用于将数据写入到指定的 CSV 文件中。
    def write_data(self, file_name, data, mode="a"):
        with open(f"{self.result_dir}/{file_name}.csv", mode, newline = "") as file:
            writer = csv.writer(file, delimiter = ',')
            writer.writerow(data)
            file.close()
    
    # 作用是将ROS参数写入YAML格式的文件中。具体来说，该函数在节点运行过程中调用
    def write_params(self):
        with open(self.result_dir + "/params.yaml", "w") as file:
            # 将参数字典装化为yaml格式
            yaml.dump({
                "model": self.model,
                "map_file": rospy.get_param("/map_file", ""),
                "scenario_file": rospy.get_param("/scenario_file", ""),
                "inter_planner": rospy.get_param(rospy.get_namespace() + "inter_planner", ""),
                "local_planner": rospy.get_param(rospy.get_namespace() + "local_planner", ""),
                "agent_name": rospy.get_param(rospy.get_namespace() + "agent_name", "burger"),
                "namespace": rospy.get_namespace().replace("/", "")
            }, file)


if __name__=="__main__":
    # 命令行解析器对象 parser
    # 这段代码的作用是在记录运行数据时解析用户输入的参数并初始化ROS节点。
    # 其中，argparse模块中的ArgumentParser()方法用于创建一个解析器对象，可以从命令行获取参数值。
    # 使用该解析器对象来指定可选参数和位置参数，以便在运行节点时接收这些参数。
    # 通过在命令行中传递--dir或-d参数可以指定结果目录的路径。如果没有指定，则会使用默认值"auto:"。
    parser = argparse.ArgumentParser()
    parser.add_argument("--dir", "-d", default="auto:")
    parser.add_argument('args', nargs=argparse.REMAINDER) # ingore extra args
    arguments = parser.parse_args()

    rospy.init_node("data_recorder", anonymous=True) # 初始化ROS节点，并将其命名为"data_recorder"，同时设置anonymous=True以避免节点名称冲突。

    
    # 用于获取数据保存的目录路径。
    def get_directory(directory:str):
        AUTO_PREFIX = "auto:/"
        PARAM_AUTO_PREFIX = "/data_recorder_autoprefix"

        if directory.startswith(AUTO_PREFIX):

            set_prefix = datetime.now().strftime("%y-%m-%d_%H-%M-%S")

            if not rospy.has_param(PARAM_AUTO_PREFIX):
                rospy.set_param(PARAM_AUTO_PREFIX, set_prefix)
            
            directory = os.path.join(str(rospy.get_param(PARAM_AUTO_PREFIX, set_prefix)), directory[len(AUTO_PREFIX):])

        return directory

    recorder = Recorder(get_directory(arguments.dir))

    # 用于重新配置 Recorder 对象的数据保存目录
    def reconfigure(directory:str):
        global recorder
        del recorder
        recorder = Recorder(get_directory(directory))
        return True

    #time.sleep(5)   
    rospy.Service("change_directory", arena_evaluation_srvs.ChangeDirectory, lambda s: reconfigure(s.data))

    rospy.spin()

